#include<iostream>
#include<queue>
using namespace std ;

// Create a Node of a Tree having four fields data , left , right and height 
class Node
{
    public: 
    int data ; 
    Node * left ;  // store the address of the left subtree
    Node * right ; // store the address of the right subtree
    int height ;  // store height of each node 

};

// Create Custom AVL tree DataStructures
class AVLTree
{
    public:
    // Create a NewNode and initialise all the fields of the Node 
    Node * createNode(int data)
    {
        Node * newNode = new Node;
        newNode->left = NULL ;
        newNode->right = NULL ;
        newNode->data = data ;
        newNode->height = 1 ;
        return newNode ;
    }
    // Making a function which returns height of the given Node
    int getHeight(Node * node)
    {
        if(node == NULL)
        {
            return 0 ;
        }
        return node->height ;
    }

    // Making a function which return the balance factor of the given Node 
    //Balance factor = the balance factor of a node is just the value we receive after subtracting the height of the right child with that of the left child of the node.
    int getBalanceFactor(Node * node){
        if(node==NULL){
            return 0;
        }
        return getHeight(node->left) - getHeight(node->right);
    }

    //we move our unbalanced node to the left
    Node * leftRotate(Node * node)
    {
        Node * temporary_Node_Pointer1  =  node -> right ;
        Node * temporary_Node_Pointer2  = temporary_Node_Pointer1->left ;

        // Now change the links 
        temporary_Node_Pointer1->left = node ;
        node -> right = temporary_Node_Pointer2 ;

        // Update the Heights of the Nodes 
        node->height = max(getHeight(node->right), getHeight(node->left)) + 1;
        temporary_Node_Pointer1->height = max(getHeight(temporary_Node_Pointer1->right), getHeight(temporary_Node_Pointer1->left)) + 1;
    
        return temporary_Node_Pointer1 ;
    }

    
    //we move our unbalanced node to the right
    Node * rightRotate(Node * node)
    {
        Node * temporary_Node_Pointer1  =  node -> left ;
        Node * temporary_Node_Pointer2  = temporary_Node_Pointer1->right ;

        // Now change the links 
        temporary_Node_Pointer1->right = node ;
        node -> left = temporary_Node_Pointer2 ;

        // Update the Heights of the Nodes 
        node->height = max(getHeight(node->right), getHeight(node->left)) + 1;
        temporary_Node_Pointer1->height = max(getHeight(temporary_Node_Pointer1->right), getHeight(temporary_Node_Pointer1->left)) + 1;
    
        return temporary_Node_Pointer1 ;
    }

    Node * insertNode(Node * root , int data )
    {
        // If Root is Null Create a new Node and insert it
        if(root==NULL)
        {
            return createNode(data);
        }
        if(root->data > data) // if data is smaller than the data of the root , then go to the left subtree
        {
            root->left = insertNode(root->left , data);
        }
        else if (root->data < data )  // if data is greater than the data of the root , then go to the right subtree
        {
            root->right = insertNode(root->right, data);
        }

        // update the height of the newNode ;
        root->height = 1 + max(getHeight(root->left), getHeight(root->right)) ;

        // find the balance factor of the node 
        int balance_factor = getBalanceFactor(root);

        // Left Left Case
        if(balance_factor>1 && data < root->left->data){
            return rightRotate(root);
        }
        // Right Right Case
            if(balance_factor<-1 && data > root->right->data){
                return leftRotate(root);
            }
        // Left Right Case
        if(balance_factor>1 && data > root->left->data){
                root->left = leftRotate(root->left);
                return rightRotate(root);
            }
        // Right Left Case
        if(balance_factor<-1 && data < root->right->data){
                root->right = rightRotate(root->right);
                return leftRotate(root);
            }
        return root ;
    }

    void preOrder(Node * root)
    {
        if(root==NULL) return ;
        preOrder(root->left);
        preOrder(root->right);
        cout<<root->data<<" ";
    }

    void printLevelOrder(Node* root)
    {
        // Base Case
        if (root == NULL)
            return;
    
        // Create an empty queue for level order traversal
        queue<Node*> q;
    
        // Enqueue Root and initialize height
        q.push(root);
    
        while (q.empty() == false) {
            // Print front of queue and remove it from queue
            Node* node = q.front();
            cout << node->data << " ";
            q.pop();
    
            /* Enqueue left child */
            if (node->left != NULL)
                q.push(node->left);
    
            /*Enqueue right child */
            if (node->right != NULL)
                q.push(node->right);
        }
    }

};


int main()
{
    // create instance of the tree class
    AVLTree t ;
    Node * root = NULL ; // root node , initially when there is no node in the tree root is NULL 
    int ch = 0 ;
    while(ch != 3)
    {
        cout<<"1. Insert Node"<<endl;
        cout<<"2. Traversal"<<endl;
        cout<<"3. Exit"<<endl;
        cout<<"Enter Your Choice"<<endl;
        cin>>ch ;

        switch(ch)
        {
            case 1:
            {
                cout<<"Enter the value of Node to insert"<<endl;
                int value ;
                cin>>value ;
                root = t.insertNode(root , value);
                break ;
            }
            case 2:
            {
                cout<<"Traversal Techniques :- "<<endl;
                cout<<"1. PreOrder"<<endl;
                cout<<"Enter Your Choice"<<endl;
                int b = 0 ;
                cin>>b ;
                if(b==1) t.preOrder(root);
                else cout<<"Invalid Choice"<<endl;
                cout<<endl;
            }

            case 3:
              cout<<"EXIT"<<endl;
              break ;
            default:
              cout<<"Invalid Choice"<<endl;
              return 0 ;
              
            
        }

    }
}
