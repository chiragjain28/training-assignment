#include<iostream>
using namespace std ;

// Create a Node of a Tree having four fields data , left , right and height 
class Node
{
    public: 
    int data ; 
    Node * left ;  // store the address of the left subtree
    Node * right ; // store the address of the right subtree
    int height ;  // store height of each node 

};

// Create Custom AVL tree DataStructures
class AVLTree
{
    public:
    // Create a NewNode and initialise all the fields of the Node 
    Node * createNode(int data)
    {
        Node * newNode = new Node;
        newNode->left = NULL ;
        newNode->right = NULL ;
        newNode->data = data ;
        newNode->height = 1 ;
        return newNode ;
    }
    // Making a function which returns height of the given Node
    int getHeight(Node * node)
    {
        if(node == NULL)
        {
            return 0 ;
        }
        return node->height ;
    }

    // Making a function which return the balance factor of the given Node 
    //Balance factor = the balance factor of a node is just the value we receive after subtracting the height of the right child with that of the left child of the node.
    int getBalanceFactor(Node * node){
        if(node==NULL){
            return 0;
        }
        return getHeight(node->left) - getHeight(node->right);
    }

    //we move our unbalanced node to the left
    Node * leftRotate(Node * node)
    {
        Node * temporary_Node_Pointer1  =  node -> right ;
        Node * temporary_Node_Pointer2  = temporary_Node_Pointer1->left ;

        // Now change the links 
        temporary_Node_Pointer1->left = node ;
        node -> right = temporary_Node_Pointer2 ;

        // Update the Heights of the Nodes 
        node->height = max(getHeight(node->right), getHeight(node->left)) + 1;
        temporary_Node_Pointer1->height = max(getHeight(temporary_Node_Pointer1->right), getHeight(temporary_Node_Pointer1->left)) + 1;
    
        return temporary_Node_Pointer1 ;
    }

    
    //we move our unbalanced node to the right
    Node * rightRotate(Node * node)
    {
        Node * temporary_Node_Pointer1  =  node -> left ;
        Node * temporary_Node_Pointer2  = temporary_Node_Pointer1->right ;

        // Now change the links 
        temporary_Node_Pointer1->right = node ;
        node -> left = temporary_Node_Pointer2 ;

        // Update the Heights of the Nodes 
        node->height = max(getHeight(node->right), getHeight(node->left)) + 1;
        temporary_Node_Pointer1->height = max(getHeight(temporary_Node_Pointer1->right), getHeight(temporary_Node_Pointer1->left)) + 1;
    
        return temporary_Node_Pointer1 ;
    }

    Node * insertNode(Node * root , int data )
    {
        // If Root is Null Create a new Node and insert it
        if(root==NULL)
        {
            return createNode(data);
        }
        if(root->data > data) // if data is smaller than the data of the root , then go to the left subtree
        {
            root->left = insertNode(root->left , data);
        }
        else if (root->data < data )  // if data is greater than the data of the root , then go to the right subtree
        {
            root->right = insertNode(root->right, data);
        }

        // update the height of the newNode ;
        root->height = 1 + max(getHeight(root->left), getHeight(root->right)) ;

        // find the balance factor of the node 
        int balance_factor = getBalanceFactor(root);

        // Left Left Case
        if(balance_factor>1 && data < root->left->data){
            return rightRotate(root);
        }
        // Right Right Case
            if(balance_factor<-1 && data > root->right->data){
                return leftRotate(root);
            }
        // Left Right Case
        if(balance_factor>1 && data > root->left->data){
                root->left = leftRotate(root->left);
                return rightRotate(root);
            }
        // Right Left Case
        if(balance_factor<-1 && data < root->right->data){
                root->right = rightRotate(root->right);
                return leftRotate(root);
            }
        return root ;
    }

    // Search Node in the Tree
    bool Search(Node* root , int value)
    {

        if(root==NULL)
        {
            return false ;
        }
        else if (root->data == value) 
        {
            return true ;
        }
        else if(value < root->data )
        {
            return Search(root->left , value);
        }
        else
        {
            return Search(root->right , value );
        }
    }

    // Preorder Traversal

    void preorder(Node *root)
    {
        if (!root)
        {
            return;
        }
        cout << root->data << " ";
        preorder(root->left);
        preorder(root->right);
    }

    // PostOrder Traversal

    void postorder(Node *root)
    {
        if (!root)
        {
            return;
        }

        postorder(root->left);
        postorder(root->right);
        cout << root->data << " ";
    }

    // Inorder Traversal

    void inorder(Node *root)
    {
        if (!root)
        {
            return;
        }

        inorder(root->left);
        cout << root->data << " ";
        inorder(root->right);
    }

};


int main()
{
    // create instance of the tree class
    AVLTree t ;
    Node * root = NULL ; // root node , initially when there is no node in the tree root is NULL 
    int ch = 0 ;
    while(ch != 4)
    {
        cout<<"1. Insert Node"<<endl;
        cout<<"2. Traversal"<<endl;
        cout<<"3. Search"<<endl;
        cout<<"4. Exit"<<endl;
        cout<<"Enter Your Choice"<<endl;
        cin>>ch ;

        switch(ch)
        {
            case 1:
            {
                cout<<"Enter the value of Node to insert"<<endl;
                int value ;
                cin>>value ;
                root = t.insertNode(root , value);
                break ;
            }
            case 2:
            {
                cout<<"Traversal Techniques :- "<<endl;
                cout<<"1. PreOrder"<<endl;
                cout<<"2. PostOrder"<<endl;
                cout<<"3. Inorder"<<endl;
                cout<<"Enter Your Choice"<<endl;
                int b = 0 ;
                cin>>b ;
                if(b==1) t.preorder(root);
                else if(b==2) t.postorder(root);
                else if(b==3) t.inorder(root);
                else cout<<"Invalid Choice"<<endl;
                cout<<endl;
                break ;
            }
            case 3:
            {
                cout<<"Enter the value of Node to Search"<<endl;
                int value ;
                cin>>value ;
                int temp = t.Search(root , value);
                if(temp) cout<<"Element Found"<<endl;
                else cout<<"Element Not Found"<<endl;
                break ;
            }
            case 4:
              cout<<"EXIT"<<endl;
              break ;
            default:
              cout<<"Invalid Choice"<<endl;
              return 0 ;
              
            
        }

    }
}
